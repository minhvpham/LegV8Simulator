{"ast":null,"code":"import { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { enableMapSet } from 'immer';\n// Enable MapSet plugin for Immer to handle Maps and Sets\nenableMapSet();\nconst initialCPUState = {\n  pc: 0x400000,\n  registers: (() => {\n    const regs = new Array(32).fill(0);\n    regs[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n    return regs;\n  })(),\n  flags: {\n    zero: false,\n    negative: false,\n    carry: false,\n    overflow: false\n  },\n  instructionMemory: [],\n  dataMemory: new Map(),\n  controlSignals: {\n    reg2Loc: false,\n    uncondBranch: false,\n    flagBranch: false,\n    zeroBranch: false,\n    memRead: false,\n    memToReg: false,\n    memWrite: false,\n    flagWrite: false,\n    aluSrc: false,\n    aluOp: '00',\n    regWrite: false\n  },\n  currentInstruction: null,\n  currentInstructionIndex: 0\n};\n\n// Helper function to execute a single instruction\nconst executeInstruction = (instruction, state) => {\n  const parts = instruction.assembly.split(/\\s+/);\n  const opcode = parts[0].toUpperCase();\n\n  // Reset control signals\n  state.controlSignals = {\n    reg2Loc: false,\n    uncondBranch: false,\n    flagBranch: false,\n    zeroBranch: false,\n    memRead: false,\n    memToReg: false,\n    memWrite: false,\n    flagWrite: false,\n    aluSrc: false,\n    aluOp: '00',\n    regWrite: false\n  };\n\n  // Parse operands\n  const parseRegister = reg => {\n    const cleanReg = reg.replace(',', '').toUpperCase();\n    if (cleanReg === 'XZR') return 31; // XZR is always 0\n    if (cleanReg === 'SP') return 28; // SP is X28\n    if (cleanReg === 'FP') return 29; // FP is X29\n    if (cleanReg === 'LR') return 30; // LR is X30\n    if (cleanReg.startsWith('X')) {\n      return parseInt(cleanReg.substring(1));\n    }\n    return 0;\n  };\n\n  // Helper function to read register value (ensures XZR always returns 0)\n  const readRegister = index => {\n    if (index === 31) return 0; // XZR always reads as 0\n    return state.registers[index] || 0;\n  };\n  const parseImmediate = imm => {\n    if (imm.startsWith('#')) {\n      return parseInt(imm.substring(1));\n    }\n    return parseInt(imm);\n  };\n  try {\n    switch (opcode) {\n      case 'ADD':\n        {\n          // ADD Rd, Rn, Rm\n          const rd = parseRegister(parts[1]);\n          const rn = parseRegister(parts[2]);\n          const rm = parseRegister(parts[3]);\n          const result = readRegister(rn) + readRegister(rm);\n          if (rd !== 31) {\n            // Don't write to XZR\n            state.registers[rd] = result;\n          }\n\n          // Set control signals\n          state.controlSignals.regWrite = true;\n          state.controlSignals.aluOp = 'ADD';\n          break;\n        }\n      case 'SUB':\n        {\n          // SUB Rd, Rn, Rm\n          const rd = parseRegister(parts[1]);\n          const rn = parseRegister(parts[2]);\n          const rm = parseRegister(parts[3]);\n          const result = readRegister(rn) - readRegister(rm);\n          if (rd !== 31) {\n            state.registers[rd] = result;\n          }\n\n          // Update flags\n          state.flags.zero = result === 0;\n          state.flags.negative = result < 0;\n          state.controlSignals.regWrite = true;\n          state.controlSignals.aluOp = 'SUB';\n          break;\n        }\n      case 'ADDI':\n        {\n          // ADDI Rd, Rn, #immediate\n          const rd = parseRegister(parts[1]);\n          const rn = parseRegister(parts[2]);\n          const immediate = parseImmediate(parts[3]);\n          const result = readRegister(rn) + immediate;\n          if (rd !== 31) {\n            state.registers[rd] = result;\n          }\n          state.controlSignals.regWrite = true;\n          state.controlSignals.aluSrc = true;\n          state.controlSignals.aluOp = 'ADD';\n          break;\n        }\n      case 'SUBI':\n        {\n          // SUBI Rd, Rn, #immediate\n          const rd = parseRegister(parts[1]);\n          const rn = parseRegister(parts[2]);\n          const immediate = parseImmediate(parts[3]);\n          const result = readRegister(rn) - immediate;\n          if (rd !== 31) {\n            state.registers[rd] = result;\n          }\n\n          // Update flags\n          state.flags.zero = result === 0;\n          state.flags.negative = result < 0;\n          state.controlSignals.regWrite = true;\n          state.controlSignals.aluSrc = true;\n          state.controlSignals.aluOp = 'SUB';\n          break;\n        }\n      case 'AND':\n        {\n          // AND Rd, Rn, Rm\n          const rd = parseRegister(parts[1]);\n          const rn = parseRegister(parts[2]);\n          const rm = parseRegister(parts[3]);\n          const result = readRegister(rn) & readRegister(rm);\n          if (rd !== 31) {\n            state.registers[rd] = result;\n          }\n          state.controlSignals.regWrite = true;\n          state.controlSignals.aluOp = 'AND';\n          break;\n        }\n      case 'ORR':\n        {\n          // ORR Rd, Rn, Rm\n          const rd = parseRegister(parts[1]);\n          const rn = parseRegister(parts[2]);\n          const rm = parseRegister(parts[3]);\n          const result = state.registers[rn] | state.registers[rm];\n          if (rd !== 31) {\n            state.registers[rd] = result;\n          }\n          state.controlSignals.regWrite = true;\n          state.controlSignals.aluOp = 'ORR';\n          break;\n        }\n      case 'STUR':\n        {\n          // STUR Rt, [Rn, #offset]\n          const rt = parseRegister(parts[1]);\n          const memoryPart = parts.slice(2).join(' ');\n          const match = memoryPart.match(/\\[([^,]+),?\\s*#?([^\\]]*)\\]/);\n          if (match) {\n            const rn = parseRegister(match[1]);\n            const offset = match[2] ? parseInt(match[2]) : 0;\n            const address = state.registers[rn] + offset;\n            state.dataMemory.set(address, state.registers[rt]);\n            state.controlSignals.memWrite = true;\n            state.controlSignals.aluSrc = true;\n          }\n          break;\n        }\n      case 'LDUR':\n        {\n          // LDUR Rt, [Rn, #offset]\n          const rt = parseRegister(parts[1]);\n          const memoryPart = parts.slice(2).join(' ');\n          const match = memoryPart.match(/\\[([^,]+),?\\s*#?([^\\]]*)\\]/);\n          if (match) {\n            const rn = parseRegister(match[1]);\n            const offset = match[2] ? parseInt(match[2]) : 0;\n            const address = state.registers[rn] + offset;\n            const value = state.dataMemory.get(address) || 0;\n            if (rt !== 31) {\n              state.registers[rt] = value;\n            }\n            state.controlSignals.memRead = true;\n            state.controlSignals.memToReg = true;\n            state.controlSignals.regWrite = true;\n            state.controlSignals.aluSrc = true;\n          }\n          break;\n        }\n      case 'CMP':\n        {\n          // CMP Rn, Rm (equivalent to SUBS XZR, Rn, Rm)\n          const rn = parseRegister(parts[1]);\n          const rm = parseRegister(parts[2]);\n          const result = state.registers[rn] - state.registers[rm];\n\n          // Update flags only\n          state.flags.zero = result === 0;\n          state.flags.negative = result < 0;\n          state.flags.carry = state.registers[rn] >= state.registers[rm];\n          state.controlSignals.flagWrite = true;\n          state.controlSignals.aluOp = 'SUB';\n          break;\n        }\n      case 'NOP':\n        {\n          // No operation\n          break;\n        }\n      default:\n        {\n          console.warn(`Instruction ${opcode} not implemented yet`);\n          break;\n        }\n    }\n\n    // Ensure XZR is always 0\n    state.registers[31] = 0;\n  } catch (error) {\n    console.error(`Error executing instruction: ${instruction.assembly}`, error);\n  }\n};\nexport const useSimulatorStore = create()(immer((set, get) => ({\n  // Initial state\n  mode: 'simulation',\n  isRunning: false,\n  isPaused: false,\n  animationSpeed: 1,\n  cpu: initialCPUState,\n  sourceCode: '',\n  currentStep: 0,\n  totalSteps: 0,\n  // Actions\n  setMode: mode => set(state => {\n    state.mode = mode;\n  }),\n  setAnimationSpeed: speed => set(state => {\n    state.animationSpeed = speed;\n  }),\n  loadProgram: instructions => set(state => {\n    state.cpu.instructionMemory = instructions;\n    state.totalSteps = instructions.length;\n    state.currentStep = 0;\n    state.cpu.pc = 0x400000;\n    state.cpu.currentInstructionIndex = 0;\n    state.cpu.currentInstruction = instructions[0] || null;\n\n    // Reset CPU state\n    state.cpu.registers = new Array(32).fill(0);\n    state.cpu.registers[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n    state.cpu.flags = {\n      zero: false,\n      negative: false,\n      carry: false,\n      overflow: false\n    };\n    state.cpu.dataMemory.clear();\n  }),\n  setSourceCode: code => set(state => {\n    state.sourceCode = code;\n  }),\n  // Execution control\n  step: () => set(state => {\n    if (state.currentStep < state.totalSteps) {\n      const currentInstruction = state.cpu.instructionMemory[state.currentStep];\n      if (currentInstruction) {\n        // Execute the current instruction\n        executeInstruction(currentInstruction, state.cpu);\n\n        // Move to next step\n        state.currentStep += 1;\n        state.cpu.pc = 0x400000 + state.currentStep * 4;\n\n        // Update current instruction info to point to the NEXT instruction\n        state.cpu.currentInstructionIndex = state.currentStep;\n        state.cpu.currentInstruction = state.cpu.instructionMemory[state.currentStep] || null;\n      }\n    }\n  }),\n  run: () => set(state => {\n    state.isRunning = true;\n    state.isPaused = false;\n  }),\n  pause: () => set(state => {\n    state.isPaused = true;\n  }),\n  reset: () => set(state => {\n    state.isRunning = false;\n    state.isPaused = false;\n    state.currentStep = 0;\n    state.cpu.pc = 0x400000;\n    state.cpu.currentInstructionIndex = 0;\n    state.cpu.currentInstruction = state.cpu.instructionMemory[0] || null;\n    state.cpu.registers = new Array(32).fill(0);\n    state.cpu.registers[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n    state.cpu.flags = {\n      zero: false,\n      negative: false,\n      carry: false,\n      overflow: false\n    };\n    state.cpu.dataMemory.clear();\n  }),\n  jumpToStep: step => set(state => {\n    if (step >= 0 && step <= state.totalSteps) {\n      // Reset to initial state\n      state.cpu.registers = new Array(32).fill(0);\n      state.cpu.registers[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n      state.cpu.flags = {\n        zero: false,\n        negative: false,\n        carry: false,\n        overflow: false\n      };\n      state.cpu.dataMemory.clear();\n\n      // Execute all instructions up to the target step\n      for (let i = 0; i < step; i++) {\n        const instruction = state.cpu.instructionMemory[i];\n        if (instruction) {\n          executeInstruction(instruction, state.cpu);\n        }\n      }\n\n      // Update current state\n      state.currentStep = step;\n      state.cpu.pc = 0x400000 + step * 4;\n      state.cpu.currentInstructionIndex = step;\n      state.cpu.currentInstruction = state.cpu.instructionMemory[step] || null;\n    }\n  }),\n  // CPU state updates\n  updateRegister: (index, value) => set(state => {\n    if (index >= 0 && index < 32 && index !== 31) {\n      // Don't allow manual update of XZR\n      state.cpu.registers[index] = value;\n    }\n    // Ensure XZR always stays 0\n    state.cpu.registers[31] = 0;\n  }),\n  updateFlags: flags => set(state => {\n    Object.assign(state.cpu.flags, flags);\n  }),\n  updatePC: value => set(state => {\n    state.cpu.pc = value;\n  }),\n  updateMemory: (address, value) => set(state => {\n    state.cpu.dataMemory.set(address, value);\n  })\n})));","map":{"version":3,"names":["create","immer","enableMapSet","initialCPUState","pc","registers","regs","Array","fill","flags","zero","negative","carry","overflow","instructionMemory","dataMemory","Map","controlSignals","reg2Loc","uncondBranch","flagBranch","zeroBranch","memRead","memToReg","memWrite","flagWrite","aluSrc","aluOp","regWrite","currentInstruction","currentInstructionIndex","executeInstruction","instruction","state","parts","assembly","split","opcode","toUpperCase","parseRegister","reg","cleanReg","replace","startsWith","parseInt","substring","readRegister","index","parseImmediate","imm","rd","rn","rm","result","immediate","rt","memoryPart","slice","join","match","offset","address","set","value","get","console","warn","error","useSimulatorStore","mode","isRunning","isPaused","animationSpeed","cpu","sourceCode","currentStep","totalSteps","setMode","setAnimationSpeed","speed","loadProgram","instructions","length","clear","setSourceCode","code","step","run","pause","reset","jumpToStep","i","updateRegister","updateFlags","Object","assign","updatePC","updateMemory"],"sources":["/home/hoangnhoo/HTMT/src/store/simulatorStore.ts"],"sourcesContent":["import { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { enableMapSet } from 'immer';\nimport { SimulatorState, CPUState, Instruction, SimulationMode } from '../types';\n\n// Enable MapSet plugin for Immer to handle Maps and Sets\nenableMapSet();\n\ninterface SimulatorStore extends SimulatorState {\n  // Actions\n  setMode: (mode: SimulationMode) => void;\n  setAnimationSpeed: (speed: number) => void;\n  loadProgram: (instructions: Instruction[]) => void;\n  setSourceCode: (code: string) => void;\n  \n  // Execution control\n  step: () => void;\n  run: () => void;\n  pause: () => void;\n  reset: () => void;\n  jumpToStep: (step: number) => void;\n  \n  // CPU state updates\n  updateRegister: (index: number, value: number) => void;\n  updateFlags: (flags: Partial<CPUState['flags']>) => void;\n  updatePC: (value: number) => void;\n  updateMemory: (address: number, value: number) => void;\n}\n\nconst initialCPUState: CPUState = {\n  pc: 0x400000,\n  registers: (() => {\n    const regs = new Array(32).fill(0);\n    regs[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n    return regs;\n  })(),\n  flags: {\n    zero: false,\n    negative: false,\n    carry: false,\n    overflow: false,\n  },\n  instructionMemory: [],\n  dataMemory: new Map(),\n  controlSignals: {\n    reg2Loc: false,\n    uncondBranch: false,\n    flagBranch: false,\n    zeroBranch: false,\n    memRead: false,\n    memToReg: false,\n    memWrite: false,\n    flagWrite: false,\n    aluSrc: false,\n    aluOp: '00',\n    regWrite: false,\n  },\n  currentInstruction: null,\n  currentInstructionIndex: 0,\n};\n\n// Helper function to execute a single instruction\nconst executeInstruction = (instruction: Instruction, state: CPUState): void => {\n  const parts = instruction.assembly.split(/\\s+/);\n  const opcode = parts[0].toUpperCase();\n  \n  // Reset control signals\n  state.controlSignals = {\n    reg2Loc: false,\n    uncondBranch: false,\n    flagBranch: false,\n    zeroBranch: false,\n    memRead: false,\n    memToReg: false,\n    memWrite: false,\n    flagWrite: false,\n    aluSrc: false,\n    aluOp: '00',\n    regWrite: false,\n  };\n\n  // Parse operands\n  const parseRegister = (reg: string): number => {\n    const cleanReg = reg.replace(',', '').toUpperCase();\n    if (cleanReg === 'XZR') return 31; // XZR is always 0\n    if (cleanReg === 'SP') return 28;  // SP is X28\n    if (cleanReg === 'FP') return 29;  // FP is X29\n    if (cleanReg === 'LR') return 30;  // LR is X30\n    if (cleanReg.startsWith('X')) {\n      return parseInt(cleanReg.substring(1));\n    }\n    return 0;\n  };\n\n  // Helper function to read register value (ensures XZR always returns 0)\n  const readRegister = (index: number): number => {\n    if (index === 31) return 0; // XZR always reads as 0\n    return state.registers[index] || 0;\n  };\n\n  const parseImmediate = (imm: string): number => {\n    if (imm.startsWith('#')) {\n      return parseInt(imm.substring(1));\n    }\n    return parseInt(imm);\n  };\n\n  try {\n    switch (opcode) {\n      case 'ADD': {\n        // ADD Rd, Rn, Rm\n        const rd = parseRegister(parts[1]);\n        const rn = parseRegister(parts[2]);\n        const rm = parseRegister(parts[3]);\n        \n        const result = readRegister(rn) + readRegister(rm);\n        if (rd !== 31) { // Don't write to XZR\n          state.registers[rd] = result;\n        }\n        \n        // Set control signals\n        state.controlSignals.regWrite = true;\n        state.controlSignals.aluOp = 'ADD';\n        break;\n      }\n\n      case 'SUB': {\n        // SUB Rd, Rn, Rm\n        const rd = parseRegister(parts[1]);\n        const rn = parseRegister(parts[2]);\n        const rm = parseRegister(parts[3]);\n        \n        const result = readRegister(rn) - readRegister(rm);\n        if (rd !== 31) {\n          state.registers[rd] = result;\n        }\n        \n        // Update flags\n        state.flags.zero = result === 0;\n        state.flags.negative = result < 0;\n        \n        state.controlSignals.regWrite = true;\n        state.controlSignals.aluOp = 'SUB';\n        break;\n      }\n\n      case 'ADDI': {\n        // ADDI Rd, Rn, #immediate\n        const rd = parseRegister(parts[1]);\n        const rn = parseRegister(parts[2]);\n        const immediate = parseImmediate(parts[3]);\n        \n        const result = readRegister(rn) + immediate;\n        if (rd !== 31) {\n          state.registers[rd] = result;\n        }\n        \n        state.controlSignals.regWrite = true;\n        state.controlSignals.aluSrc = true;\n        state.controlSignals.aluOp = 'ADD';\n        break;\n      }\n\n      case 'SUBI': {\n        // SUBI Rd, Rn, #immediate\n        const rd = parseRegister(parts[1]);\n        const rn = parseRegister(parts[2]);\n        const immediate = parseImmediate(parts[3]);\n        \n        const result = readRegister(rn) - immediate;\n        if (rd !== 31) {\n          state.registers[rd] = result;\n        }\n        \n        // Update flags\n        state.flags.zero = result === 0;\n        state.flags.negative = result < 0;\n        \n        state.controlSignals.regWrite = true;\n        state.controlSignals.aluSrc = true;\n        state.controlSignals.aluOp = 'SUB';\n        break;\n      }\n\n      case 'AND': {\n        // AND Rd, Rn, Rm\n        const rd = parseRegister(parts[1]);\n        const rn = parseRegister(parts[2]);\n        const rm = parseRegister(parts[3]);\n        \n        const result = readRegister(rn) & readRegister(rm);\n        if (rd !== 31) {\n          state.registers[rd] = result;\n        }\n        \n        state.controlSignals.regWrite = true;\n        state.controlSignals.aluOp = 'AND';\n        break;\n      }\n\n      case 'ORR': {\n        // ORR Rd, Rn, Rm\n        const rd = parseRegister(parts[1]);\n        const rn = parseRegister(parts[2]);\n        const rm = parseRegister(parts[3]);\n        \n        const result = state.registers[rn] | state.registers[rm];\n        if (rd !== 31) {\n          state.registers[rd] = result;\n        }\n        \n        state.controlSignals.regWrite = true;\n        state.controlSignals.aluOp = 'ORR';\n        break;\n      }\n\n      case 'STUR': {\n        // STUR Rt, [Rn, #offset]\n        const rt = parseRegister(parts[1]);\n        const memoryPart = parts.slice(2).join(' ');\n        const match = memoryPart.match(/\\[([^,]+),?\\s*#?([^\\]]*)\\]/);\n        \n        if (match) {\n          const rn = parseRegister(match[1]);\n          const offset = match[2] ? parseInt(match[2]) : 0;\n          const address = state.registers[rn] + offset;\n          \n          state.dataMemory.set(address, state.registers[rt]);\n          \n          state.controlSignals.memWrite = true;\n          state.controlSignals.aluSrc = true;\n        }\n        break;\n      }\n\n      case 'LDUR': {\n        // LDUR Rt, [Rn, #offset]\n        const rt = parseRegister(parts[1]);\n        const memoryPart = parts.slice(2).join(' ');\n        const match = memoryPart.match(/\\[([^,]+),?\\s*#?([^\\]]*)\\]/);\n        \n        if (match) {\n          const rn = parseRegister(match[1]);\n          const offset = match[2] ? parseInt(match[2]) : 0;\n          const address = state.registers[rn] + offset;\n          \n          const value = state.dataMemory.get(address) || 0;\n          if (rt !== 31) {\n            state.registers[rt] = value;\n          }\n          \n          state.controlSignals.memRead = true;\n          state.controlSignals.memToReg = true;\n          state.controlSignals.regWrite = true;\n          state.controlSignals.aluSrc = true;\n        }\n        break;\n      }\n\n      case 'CMP': {\n        // CMP Rn, Rm (equivalent to SUBS XZR, Rn, Rm)\n        const rn = parseRegister(parts[1]);\n        const rm = parseRegister(parts[2]);\n        \n        const result = state.registers[rn] - state.registers[rm];\n        \n        // Update flags only\n        state.flags.zero = result === 0;\n        state.flags.negative = result < 0;\n        state.flags.carry = state.registers[rn] >= state.registers[rm];\n        \n        state.controlSignals.flagWrite = true;\n        state.controlSignals.aluOp = 'SUB';\n        break;\n      }\n\n      case 'NOP': {\n        // No operation\n        break;\n      }\n\n      default: {\n        console.warn(`Instruction ${opcode} not implemented yet`);\n        break;\n      }\n    }\n\n    // Ensure XZR is always 0\n    state.registers[31] = 0;\n\n  } catch (error) {\n    console.error(`Error executing instruction: ${instruction.assembly}`, error);\n  }\n};\n\nexport const useSimulatorStore = create<SimulatorStore>()(\n  immer((set, get) => ({\n    // Initial state\n    mode: 'simulation',\n    isRunning: false,\n    isPaused: false,\n    animationSpeed: 1,\n    cpu: initialCPUState,\n    sourceCode: '',\n    currentStep: 0,\n    totalSteps: 0,\n\n    // Actions\n    setMode: (mode) =>\n      set((state) => {\n        state.mode = mode;\n      }),\n\n    setAnimationSpeed: (speed) =>\n      set((state) => {\n        state.animationSpeed = speed;\n      }),\n\n    loadProgram: (instructions) =>\n      set((state) => {\n        state.cpu.instructionMemory = instructions;\n        state.totalSteps = instructions.length;\n        state.currentStep = 0;\n        state.cpu.pc = 0x400000;\n        state.cpu.currentInstructionIndex = 0;\n        state.cpu.currentInstruction = instructions[0] || null;\n        \n        // Reset CPU state\n        state.cpu.registers = new Array(32).fill(0);\n        state.cpu.registers[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n        state.cpu.flags = {\n          zero: false,\n          negative: false,\n          carry: false,\n          overflow: false,\n        };\n        state.cpu.dataMemory.clear();\n      }),\n\n    setSourceCode: (code) =>\n      set((state) => {\n        state.sourceCode = code;\n      }),\n\n    // Execution control\n    step: () =>\n      set((state) => {\n        if (state.currentStep < state.totalSteps) {\n          const currentInstruction = state.cpu.instructionMemory[state.currentStep];\n          \n          if (currentInstruction) {\n            // Execute the current instruction\n            executeInstruction(currentInstruction, state.cpu);\n            \n            // Move to next step\n            state.currentStep += 1;\n            state.cpu.pc = 0x400000 + state.currentStep * 4;\n            \n            // Update current instruction info to point to the NEXT instruction\n            state.cpu.currentInstructionIndex = state.currentStep;\n            state.cpu.currentInstruction = state.cpu.instructionMemory[state.currentStep] || null;\n          }\n        }\n      }),\n\n    run: () =>\n      set((state) => {\n        state.isRunning = true;\n        state.isPaused = false;\n      }),\n\n    pause: () =>\n      set((state) => {\n        state.isPaused = true;\n      }),\n\n    reset: () =>\n      set((state) => {\n        state.isRunning = false;\n        state.isPaused = false;\n        state.currentStep = 0;\n        state.cpu.pc = 0x400000;\n        state.cpu.currentInstructionIndex = 0;\n        state.cpu.currentInstruction = state.cpu.instructionMemory[0] || null;\n        state.cpu.registers = new Array(32).fill(0);\n        state.cpu.registers[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n        state.cpu.flags = {\n          zero: false,\n          negative: false,\n          carry: false,\n          overflow: false,\n        };\n        state.cpu.dataMemory.clear();\n      }),\n\n    jumpToStep: (step) =>\n      set((state) => {\n        if (step >= 0 && step <= state.totalSteps) {\n          // Reset to initial state\n          state.cpu.registers = new Array(32).fill(0);\n          state.cpu.registers[28] = 0x80000000; // SP (Stack Pointer) starts at 0x80000000\n          state.cpu.flags = {\n            zero: false,\n            negative: false,\n            carry: false,\n            overflow: false,\n          };\n          state.cpu.dataMemory.clear();\n          \n          // Execute all instructions up to the target step\n          for (let i = 0; i < step; i++) {\n            const instruction = state.cpu.instructionMemory[i];\n            if (instruction) {\n              executeInstruction(instruction, state.cpu);\n            }\n          }\n          \n          // Update current state\n          state.currentStep = step;\n          state.cpu.pc = 0x400000 + step * 4;\n          state.cpu.currentInstructionIndex = step;\n          state.cpu.currentInstruction = state.cpu.instructionMemory[step] || null;\n        }\n      }),\n\n    // CPU state updates\n    updateRegister: (index, value) =>\n      set((state) => {\n        if (index >= 0 && index < 32 && index !== 31) { // Don't allow manual update of XZR\n          state.cpu.registers[index] = value;\n        }\n        // Ensure XZR always stays 0\n        state.cpu.registers[31] = 0;\n      }),\n\n    updateFlags: (flags) =>\n      set((state) => {\n        Object.assign(state.cpu.flags, flags);\n      }),\n\n    updatePC: (value) =>\n      set((state) => {\n        state.cpu.pc = value;\n      }),\n\n    updateMemory: (address, value) =>\n      set((state) => {\n        state.cpu.dataMemory.set(address, value);\n      }),\n  }))\n); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}